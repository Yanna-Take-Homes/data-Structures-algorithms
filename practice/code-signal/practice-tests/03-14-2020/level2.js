/*
    Codewriting -- AlternatingSort

    You are given an array of integers a. A new array b is generated by rearranging the elements of a in the following way:

    b[0] is equal to a[0];
    b[1] is equal to the last element of a;
    b[2] is equal to a[1];
    b[3] is equal to the second-last element of a;
    and so on.
    Your task is to determine whether the new array b is sorted in strictly ascending order or not.

    Example

    For a = [1, 3, 5, 6, 4, 2], the output should be alternatingSort(a) = true.

    The new array b will look like [1, 2, 3, 4, 5, 6], which is in strictly ascending order, so the answer is true.

    For a = [1, 4, 5, 6, 3], the output should be alternatingSort(a) = false.

    The new array b will look like [1, 3, 4, 6, 5], which is not in strictly ascending order, so the answer is false.

    Input/Output

    [execution time limit] 4 seconds (js)

    [input] array.integer a

    The given array of integers.

    Guaranteed constraints:
    1 ≤ a.length ≤ 105,
    -109 ≤ a[i] ≤ 109.

    [output] boolean

    A boolean representing whether the new array b will be sorted in strictly ascending order or not.
*/

/*
    Problem in own words
    -----------------------
    Given array a, create an array b such that
        b[ 0 ] == a[ 0 ]
        b [ 1 ] == a[ a.length - 1 ]
        b[ 2 ] == a[ 1 ]
        b [ 3 ] == a[ a.length - 2 ]
        and so on.

    Algorithm
    --------------
    - Notice that all even numbered indexes of b will get elemets from a in regular order, and all odd numbered indexes from b will get elements from a in reverse order. 

    1) - create four temp variables, tempEven, tempOdd, prevNew and curNew
        - set PrevNew to a[ 0 ]
        - set tempEven to 1 and tempOdd to a.length-1

    2) Iterate through array a, staring at first element and ending at a.length since we are not using i to get
    elements, but rather tempEven and tempOdd, and tempEven starts at 1. 
        - if idx is even, set curNew to element at tempEven and increment tempEven upwards.
        - if idx is odd, set curNew to element at tempOdd and incremenet tempOdd downwards. 
        - if curNew < prevNew then return false, since the current element should be greater than the previous. 

    Edge Cases
    ---------------
    1) What if array is empty? --> return false.
    2) What if array contains duplicates? --> return false. The sorted array wouldn't be *strictly ascending* 

*/

function alternatingSort( a ) {
    if ( a.length === 0 ) return false;
    if ( new Set( a ).size !== a.length ) return false; 

    let tempEven = 1;
    let tempOdd = a.length-1;
    let prevNew = a[ 0 ];
    let curNew;
    
    for ( let i = 1; i < a.length; i++ ) {
        if ( i % 2 === 0 ) {
            curNew = a[ tempEven ];
            tempEven ++;
        } else {
            curNew = a[ tempOdd ];
            tempOdd --;
        }
        if ( curNew < prevNew ) return false;
        prevNew = curNew;
    }

    return true;
}

// a = [1];
// console.log( alternatingSort( a ) );

/*
    Test Cases
    -----------------
    [1, 4, 5, 6, 3] --> false
    [1, 3, 5, 6, 4, 2] --> true
    [1, 4, 5, 5, 6, 3] --> false;
    [1] --> true;
*/

/*
    Big O
    -----------
    Our time complexity is O( n ) algorithm, since we use a for-loop to iterate through the input array. 
    Our space complexity is O( 1 ), since our function will always use 4 (static-sized) temporary variables. 

*/

/*
    Questions/Thoughts
    -----------------------
    Is turning an array into a set a O( n ) operation?
*/

